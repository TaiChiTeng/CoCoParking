我准备做一款2D游戏，使用CocosCreator3.8.6，TypeScripts。
需要你实现：
（1）存好每一关地图的MapW、MapH、Map[][]。
（2）根据当前关卡数，获取对应的MapW、MapH、Map[][]。
（3）根据获取到的MapW、MapH、Map[][]，创建地图。
（4）地图数据要放在一个单独的文件里，每个关卡对应一个文件，文件名是关卡数比如lv1.ts，放在同一个文件夹下，文件夹名是Map。
（5）接下来，根据关卡地图数据放置阻挡：
    比如，如果Map[0][0]是-1，则将UILevel/AnimNode/nodeBlock/texBlock00设置为可见。
    即，如果Map[i][j]是-1，则将UILevel/AnimNode/nodeBlock/texBlockij设置为可见，其余的都设置为不可见。
（6）根据关卡地图数据，设置汽车的初始位置和类型。
    （6.1）关卡地图：要增加汽车数据，先只做在地图下方的汽车，3种预制：itemCarU1、itemCarU2、itemCarU3。
    （6.2）地图下方有5个节点：nodeU0、nodeU1、nodeU2、nodeU3、nodeU4。
    （6.3）举例子：如果本关汽车数据是：
        第1辆汽车是{地图外部：U0，排序是0，类型是3}
        第2辆汽车是{地图外部：U1，排序是0，类型是2}
        第3辆汽车是{地图外部：U1，排序是1，类型是1}
        那么，按下面步骤初始化创建汽车：
        （a）创建预制itemCarU3，父节点是UILevel/AnimNode/nodeCar/nodeU0
        （b）创建预制itemCarU2，父节点是UILevel/AnimNode/nodeCar/nodeU1
        （c）创建预制itemCarU1，父节点是UILevel/AnimNode/nodeCar/nodeU2
    第1关的汽车数据是：
        第1辆汽车是{地图外部：U0，排序是0，类型是3}
        第2辆汽车是{地图外部：U1，排序是0，类型是2}
        第3辆汽车是{地图外部：U2，排序是0，类型是1}
    第2关的汽车数据是：
        第1辆汽车是{地图外部：U0，排序是0，类型是3}
        第2辆汽车是{地图外部：U1，排序是0，类型是2}
        第3辆汽车是{地图外部：U1，排序是1，类型是1}
    第3关的汽车数据是：
        第1辆汽车是{地图外部：U1，排序是0，类型是3}
        第2辆汽车是{地图外部：U2，排序是0，类型是3}
        第3辆汽车是{地图外部：U2，排序是1，类型是3}
        第4辆汽车是{地图外部：U3，排序是0，类型是3}
    第4关的汽车数据是：
        第1辆汽车是{地图外部：U0，排序是0，类型是3}
        第2辆汽车是{地图外部：U4，排序是0，类型是3}
    第5关的汽车数据是：
        第1辆汽车是{地图外部：U0，排序是0，类型是3}
（7）再次扩展关卡地图数据，设置在地图右方汽车的初始位置和类型。
    （7.1）关卡地图：要继续增加在地图右方的汽车数据，3种预制：itemCarL1、itemCarL2、itemCarL3。
    （7.2）地图右方有6个节点：nodeL0、nodeL1、nodeL2、nodeL3、nodeL4、nodeL5。
    （7.3）举例子：如果本关地图右方汽车数据是：
        第1辆汽车是{地图外部：L0，排序是0，类型是3}
        第2辆汽车是{地图外部：L1，排序是0，类型是2}
        第3辆汽车是{地图外部：L1，排序是1，类型是1}
        那么，按下面步骤初始化创建汽车：
        （a）创建预制itemCarL3，父节点是UILevel/AnimNode/nodeCar/nodeL0
        （b）创建预制itemCarL2，父节点是UILevel/AnimNode/nodeCar/nodeL1
        （c）创建预制itemCarL1，父节点是UILevel/AnimNode/nodeCar/nodeL2
    第1关的汽车数据是：
        第1辆汽车是{地图外部：U0，排序是0，类型是3}
        第2辆汽车是{地图外部：U1，排序是0，类型是2}
        第3辆汽车是{地图外部：U2，排序是0，类型是1}
    第2关的汽车数据是：
        第1辆汽车是{地图外部：U0，排序是0，类型是3}
        第2辆汽车是{地图外部：U1，排序是0，类型是2}
        第3辆汽车是{地图外部：U1，排序是1，类型是1}
    第3关的汽车数据是：
        第1辆汽车是{地图外部：U1，排序是0，类型是3}
        第2辆汽车是{地图外部：U2，排序是0，类型是3}
        第3辆汽车是{地图外部：U2，排序是1，类型是3}
        第4辆汽车是{地图外部：U3，排序是0，类型是3}
        第5辆汽车是{地图外部：L0，排序是0，类型是2}
        第6辆汽车是{地图外部：L4，排序是0，类型是2}
    第4关的汽车数据是：
        第1辆汽车是{地图外部：U0，排序是0，类型是3}
        第2辆汽车是{地图外部：U4，排序是0，类型是3}
        第3辆汽车是{地图外部：L3，排序是0，类型是1}
        第4辆汽车是{地图外部：L3，排序是1，类型是1}
    第5关的汽车数据是：
        第1辆汽车是{地图外部：U0，排序是0，类型是3}
        第2辆汽车是{地图外部：L1，排序是0，类型是3}
        第3辆汽车是{地图外部：L3，排序是0，类型是3}
        第4辆汽车是{地图外部：L4，排序是0，类型是3}
（8）再次扩展关卡地图数据，设置在地图左方汽车的初始位置和类型。
    （8.1）关卡地图：要继续增加在地图左方的汽车数据，3种预制：itemCarR1、itemCarR2、itemCarR3。
    （8.2）地图左方有6个节点：nodeR0、nodeR1、nodeR2、nodeR3、nodeR4、nodeR5。
    （8.3）举例子：如果本关地图左方汽车数据是：
        第1辆汽车是{地图外部：R0，排序是0，类型是3}
        第2辆汽车是{地图外部：R1，排序是0，类型是2}
        第3辆汽车是{地图外部：R1，排序是1，类型是1}
        那么，按下面步骤初始化创建汽车：
        （a）创建预制itemCarR3，父节点是UILevel/AnimNode/nodeCar/nodeR0
        （b）创建预制itemCarR2，父节点是UILevel/AnimNode/nodeCar/nodeR1
        （c）创建预制itemCarR1，父节点是UILevel/AnimNode/nodeCar/nodeR2
    第1关的汽车数据是：
        第1辆汽车是{地图外部：U0，排序是0，类型是3}
        第2辆汽车是{地图外部：U1，排序是0，类型是2}
        第3辆汽车是{地图外部：U2，排序是0，类型是1}
    第2关的汽车数据是：
        第1辆汽车是{地图外部：U0，排序是0，类型是3}
        第2辆汽车是{地图外部：U1，排序是0，类型是2}
        第3辆汽车是{地图外部：U1，排序是1，类型是1}
        第4辆汽车是{地图外部：R0，排序是0，类型是2}
        第5辆汽车是{地图外部：R0，排序是1，类型是1}
        第6辆汽车是{地图外部：R1，排序是0，类型是3}
        第7辆汽车是{地图外部：R2，排序是0，类型是3}
    第3关的汽车数据是：
        第1辆汽车是{地图外部：U1，排序是0，类型是3}
        第2辆汽车是{地图外部：U2，排序是0，类型是3}
        第3辆汽车是{地图外部：U2，排序是1，类型是3}
        第4辆汽车是{地图外部：U3，排序是0，类型是3}
        第5辆汽车是{地图外部：L0，排序是0，类型是2}
        第6辆汽车是{地图外部：L4，排序是0，类型是2}
        第7辆汽车是{地图外部：R0，排序是0，类型是2}
        第8辆汽车是{地图外部：R4，排序是0，类型是2}
    第4关的汽车数据是：
        第1辆汽车是{地图外部：U0，排序是0，类型是3}
        第2辆汽车是{地图外部：U4，排序是0，类型是3}
        第3辆汽车是{地图外部：L3，排序是0，类型是1}
        第4辆汽车是{地图外部：L3，排序是1，类型是1}
        第5辆汽车是{地图外部：R4，排序是0，类型是2}
        第6辆汽车是{地图外部：R4，排序是1，类型是1}
    第5关的汽车数据是：
        第1辆汽车是{地图外部：U0，排序是0，类型是3}
        第2辆汽车是{地图外部：L1，排序是0，类型是3}
        第3辆汽车是{地图外部：L3，排序是0，类型是3}
        第4辆汽车是{地图外部：L4，排序是0，类型是3}
        第5辆汽车是{地图外部：R2，排序是0，类型是3}
        第6辆汽车是{地图外部：R5，排序是0，类型是3}
（9）点击汽车时，，打印父节点，汽车预制名称，汽车世界坐标。并且，隐藏汽车active = false。
    另外，以UILevel/AnimNode/nodePark为父节点，用汽车世界坐标+(0,600)的世界坐标创建新的汽车预制。
（10）点击汽车时，
        （10.1）如果是Ux的汽车，即地图下方的汽车，遍历检查Map[x][MapH-1]到Map[x][0]：
                找出最后一个是零的i，遍历过程同时统计Map[x][i]是零的总数量。
        （10.2）如果零的总数量<汽车长度，那么停车失败。
        （10.3）如果零的总数量≥汽车长度，那么停车成功：
            （a）成功停车计数+1。Map[x][i]~Map[x][i+汽车长度–1]都从0变为1。
            （b）隐藏被点击的汽车active = false。
            （c）以UILevel/AnimNode/nodePark为父节点，用被点击的汽车世界坐标+(0,100*i)的世界坐标创建新的汽车预制。
            （d）检查是否已停满所有汽车
（11）新的关卡，要删除掉UILevel/AnimNode/nodePark里边所有子节点
（12）让ai解耦合
（13）创建汽车时，汽车的坐标需要根据汽车类型type和排序sort适配：
    （13.1）同样在Ux的汽车，第1辆type=2汽车是(0,0),第2辆type=3汽车是第1辆汽车坐标-(0,100*第1辆type),第3辆type=1汽车是第2辆汽车坐标-(0,100*第2辆type)。
    （13.2）同样在Lx的汽车，第1辆type=2汽车是(0,0),第2辆type=3汽车是第1辆汽车坐标+(100*第1辆type,0),第3辆type=1汽车是第2辆汽车坐标+(100*第2辆type,0)。
    （13.3）同样在Rx的汽车，第1辆type=2汽车是(0,0),第2辆type=3汽车是第1辆汽车坐标-(100*第1辆type,0),第3辆type=1汽车是第2辆汽车坐标-(100*第2辆type,0)。
（14）创建完汽车后，要根据需停好的汽车存若干份地图外的停车信息数据。
    （14.1）Ux的汽车，根据Ux里所有汽车的sort和type，存一份数据：地图外的停车信息，记作OutMapUx[Ux的汽车占用空间]。
        比如，Ux的汽车：
            第1辆汽车是{地图外部：U0，排序是0，类型是3},
            第2辆汽车是{地图外部：U1，排序是0，类型是2}，
            第3辆汽车是{地图外部：U1，排序是1，类型是1}，
        那么，OutMapU1只有1辆长度3的车，OutMapU1[3] = {1,1,1}，
            OutMapU2有1辆长度2和1辆长度1的车，OutMapU2[3] = {1,1,1}，
    （14.2）Lx的汽车，根据Lx里所有汽车的sort和type，存一份数据：地图外的停车信息，记作OutMapLx[Lx的汽车占用空间]。
        比如，Lx的汽车：
            第1辆汽车是{地图外部：L3，排序是0，类型是1},
            第2辆汽车是{地图外部：L3，排序是1，类型是1},
        那么，OutMapL3有1辆长度1和1辆长度1的车，OutMapL3[2] = {1,1}，
    （14.3）Rx的汽车，根据Rx里所有汽车的sort和type，存一份数据：地图外的停车信息，记作OutMapRx[Rx的汽车占用空间]。
        比如，Rx的汽车：
            第1辆汽车是{地图外部：R2，排序是0，类型是3},
            第2辆汽车是{地图外部：R5，排序是0，类型是3},
        那么，OutMapR2只有1辆长度3的车，OutMapR2[3] = {1,1,1}，
            OutMapR5只有1辆长度3的车，OutMapR5[3] = {1,1,1}。
    （14.4）OutMapUx,OutMapLx,OutMapRx需要整整一关游戏过程，都可以快速获取它的值
（15）创建完汽车后，要结合Map[][]和OutMapUx[]、OutMapLx[]、OutMapRx[]为每一辆汽车存停在哪里的信息数据，而且也是需要整整一关游戏过程，都可以快速获取它的值。
    第1辆汽车是{地图外部：U0，排序是0，类型是3}，
    第2辆汽车是{地图外部：U1，排序是0，类型是2}，
    第3辆汽车是{地图外部：U1，排序是1，类型是1}，
    第4辆汽车是{地图外部：R0，排序是0，类型是2}，
    第5辆汽车是{地图外部：R0，排序是1，类型是1}，
    第6辆汽车是{地图外部：R1，排序是0，类型是3}，
    第7辆汽车是{地图外部：R2，排序是0，类型是3}，
    第8辆汽车是{地图外部：L1，排序是0，类型是3}
    那么，Car1停在OutMapU0[]的0,1,2，记作Car1Stop[3]={0+mapH,1+mapH,2+mapH}，
        Car2停在OutMapU1[]的0,1，记作Car2Stop[2]={0+mapH,1+mapH}，
        Car3停在OutMapU1[]的2，记作Car3Stop[1]={2+mapH}，
        Car4停在OutMapR0[]的0,1，记作Car4Stop[2]={0-mapW,1-mapW}，
        Car5停在OutMapR0[]的2，记作Car5Stop[1]={2-mapW}，
        Car6停在OutMapR1[]的0,1,2，记作Car6Stop[3]={0-mapW,1-mapW,2-mapW}，
        Car7停在OutMapR2[]的0,1,2，记作Car7Stop[3]={0-mapW,1-mapW,2-mapW}，
        Car8停在OutMapL1[]的0,1,2，记作Car8Stop[3]={0+mapW,1+mapW,2+mapW}，

（15）点击汽车时，
    （15.1）假设是Ux的汽车，即地图下方的汽车，
    （15.2）先检查汽车现在停在哪里，然后检查是否可以向上开，
        （a）例如，点击的汽车是：U0，Car1 停放位置: [6,7,8]，而Map[0][] = {0,0,0,0,0,0}
        （b）停放位置[0]=6已经＞mapH了且Map[0][6]=0，那么可以向上开，并且是尽量开到尽头，所以数据就更新为U0，Car1 停放位置: [0,1,2]，而Map[0][] = {1,1,1,0,0,0}。
    （15.3）如果不可以向上开，则检查是否可以向下开，
        （a）例如，点击的汽车是：U0，Car1 停放位置: [0,1,2]，而Map[0][] = {1,1,1,0,0,0}
        （b）停放位置[0]=0已经不可以再向上开了，那么检查是否可以向下开。因为Map[0][3],Map[0][4],Map[0][5]都是0,Map[0][5]已经到停车场底部，那么可以向下开，并且是尽量开到尽头，所以还要再检查停车场下方外部。
        （c）如果U0只有Car1一辆车，那么Car1向下开，直到停在OutMapU0[]的0,1,2，记作Car1Stop[3]={0+mapH,1+mapH,2+mapH}，
        （d）如果U0还有Car2 停放位置：[6,7]，Car3 停放位置：[8]，那么Car1，Car2，Car3这3辆车都一起向下开直到都离开停车场，停在停车场下方外部，数据更新为Car1 停放位置: [6,7,8]，Car2 停放位置：[9,10]，Car3 停放位置：[11]，而Map[0][] = {0,0,0,0,0,0}
    （15.4）更新汽车的世界坐标，每移动1个单位，是100，向上是+100，向下是-100，向左是-100，向右是+100。
        （a1）例如，点击的汽车是：U0，Car1 停放位置: [0,1,2]，而Map[0][] = {1,1,1,0,0,1}
        （b1）停放位置[0]=0已经不可以再向上开了，那么检查是否可以向下开。因为Map[0][3],Map[0][4]都是0,Map[0][5]已经到停车场底部，那么可以向下开到Map[0][4]，数据更新为Car1 停放位置: [2,3,4]，而Map[0][] = {0,0,1,1,1,1}，注意，这种情况下，U0如果还有其它车子，这些车子都不用移动。
    （15.5）如果汽车向上开，那么停车成功：
        （a）成功停车计数+1，
        （d）检查是否已停好所有汽车，如果是，则通关！
    （15.6）如果汽车向下开，并且完全离开停车场，那么成功停车计数-1：
    （15.7）注意，不用再以UILevel/AnimNode/nodePark为父节点创建新的汽车预制了，删掉相关的代码。


地图说明：
（1）是二维数组Map[i][j]，MapW和MapH分别是i和j的上限。
（2）如果Map[i][j]为-1，表示有永久阻挡。
第1关地图：
MapW=5,MapH=6,Map[][]={
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0}。
第2关地图：
MapW=5,MapH=6,Map[][]={
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,-1,-1,-1}。
第3关地图：
MapW=5,MapH=6,Map[][]={
    0,0,0,0,0,
    -1,0,0,0,-1,
    -1,0,0,0,-1,
    -1,0,0,0,-1,
    0,0,0,0,0,
    -1,0,0,0,-1}。
第4关地图：
MapW=5,MapH=6,Map[][]={
    0,0,0,0,0,
    -1,0,0,0,-1,
    0,0,0,0,0,
    0,-1,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0}。
第5关地图：
MapW=5,MapH=6,Map[][]={
    -1,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,-1}。
