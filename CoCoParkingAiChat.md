我准备做一款2D游戏，使用CocosCreator3.8.6，TypeScripts。
需要你实现：
（1）存好每一关地图的MapW、MapH、Map[][]。
（2）根据当前关卡数，获取对应的MapW、MapH、Map[][]。
（3）根据获取到的MapW、MapH、Map[][]，创建地图。
（4）地图数据要放在一个单独的文件里，每个关卡对应一个文件，文件名是关卡数比如lv1.ts，放在同一个文件夹下，文件夹名是Map。
（5）接下来，根据关卡地图数据放置阻挡：
    比如，如果Map[0][0]是-1，则将UILevel/AnimNode/nodeBlock/texBlock00设置为可见。
    即，如果Map[i][j]是-1，则将UILevel/AnimNode/nodeBlock/texBlockij设置为可见，其余的都设置为不可见。
（6）根据关卡地图数据，设置汽车的初始位置和类型。
    （6.1）关卡地图：要增加汽车数据，先只做在地图下方的汽车，3种预制：itemCarU1、itemCarU2、itemCarU3。
    （6.2）地图下方有5个节点：nodeU0、nodeU1、nodeU2、nodeU3、nodeU4。
    （6.3）举例子：如果本关汽车数据是：
        第1辆汽车是{地图外部：U0，排序是0，类型是3}
        第2辆汽车是{地图外部：U1，排序是0，类型是2}
        第3辆汽车是{地图外部：U1，排序是1，类型是1}
        那么，按下面步骤初始化创建汽车：
        （a）创建预制itemCarU3，父节点是UILevel/AnimNode/nodeCar/nodeU0
        （b）创建预制itemCarU2，父节点是UILevel/AnimNode/nodeCar/nodeU1
        （c）创建预制itemCarU1，父节点是UILevel/AnimNode/nodeCar/nodeU2
    第1关的汽车数据是：
        第1辆汽车是{地图外部：U0，排序是0，类型是3}
        第2辆汽车是{地图外部：U1，排序是0，类型是2}
        第3辆汽车是{地图外部：U2，排序是0，类型是1}
    第2关的汽车数据是：
        第1辆汽车是{地图外部：U0，排序是0，类型是3}
        第2辆汽车是{地图外部：U1，排序是0，类型是2}
        第3辆汽车是{地图外部：U1，排序是1，类型是1}
    第3关的汽车数据是：
        第1辆汽车是{地图外部：U1，排序是0，类型是3}
        第2辆汽车是{地图外部：U2，排序是0，类型是3}
        第3辆汽车是{地图外部：U2，排序是1，类型是3}
        第4辆汽车是{地图外部：U3，排序是0，类型是3}
    第4关的汽车数据是：
        第1辆汽车是{地图外部：U0，排序是0，类型是3}
        第2辆汽车是{地图外部：U4，排序是0，类型是3}
    第5关的汽车数据是：
        第1辆汽车是{地图外部：U0，排序是0，类型是3}
（7）再次扩展关卡地图数据，设置在地图右方汽车的初始位置和类型。
    （7.1）关卡地图：要继续增加在地图右方的汽车数据，3种预制：itemCarL1、itemCarL2、itemCarL3。
    （7.2）地图右方有6个节点：nodeL0、nodeL1、nodeL2、nodeL3、nodeL4、nodeL5。
    （7.3）举例子：如果本关地图右方汽车数据是：
        第1辆汽车是{地图外部：L0，排序是0，类型是3}
        第2辆汽车是{地图外部：L1，排序是0，类型是2}
        第3辆汽车是{地图外部：L1，排序是1，类型是1}
        那么，按下面步骤初始化创建汽车：
        （a）创建预制itemCarL3，父节点是UILevel/AnimNode/nodeCar/nodeL0
        （b）创建预制itemCarL2，父节点是UILevel/AnimNode/nodeCar/nodeL1
        （c）创建预制itemCarL1，父节点是UILevel/AnimNode/nodeCar/nodeL2
    第1关的汽车数据是：
        第1辆汽车是{地图外部：U0，排序是0，类型是3}
        第2辆汽车是{地图外部：U1，排序是0，类型是2}
        第3辆汽车是{地图外部：U2，排序是0，类型是1}
    第2关的汽车数据是：
        第1辆汽车是{地图外部：U0，排序是0，类型是3}
        第2辆汽车是{地图外部：U1，排序是0，类型是2}
        第3辆汽车是{地图外部：U1，排序是1，类型是1}
    第3关的汽车数据是：
        第1辆汽车是{地图外部：U1，排序是0，类型是3}
        第2辆汽车是{地图外部：U2，排序是0，类型是3}
        第3辆汽车是{地图外部：U2，排序是1，类型是3}
        第4辆汽车是{地图外部：U3，排序是0，类型是3}
        第5辆汽车是{地图外部：L0，排序是0，类型是2}
        第6辆汽车是{地图外部：L4，排序是0，类型是2}
    第4关的汽车数据是：
        第1辆汽车是{地图外部：U0，排序是0，类型是3}
        第2辆汽车是{地图外部：U4，排序是0，类型是3}
        第3辆汽车是{地图外部：L3，排序是0，类型是1}
        第4辆汽车是{地图外部：L3，排序是1，类型是1}
    第5关的汽车数据是：
        第1辆汽车是{地图外部：U0，排序是0，类型是3}
        第2辆汽车是{地图外部：L1，排序是0，类型是3}
        第3辆汽车是{地图外部：L3，排序是0，类型是3}
        第4辆汽车是{地图外部：L4，排序是0，类型是3}
（8）再次扩展关卡地图数据，设置在地图左方汽车的初始位置和类型。
    （8.1）关卡地图：要继续增加在地图左方的汽车数据，3种预制：itemCarR1、itemCarR2、itemCarR3。
    （8.2）地图左方有6个节点：nodeR0、nodeR1、nodeR2、nodeR3、nodeR4、nodeR5。
    （8.3）举例子：如果本关地图左方汽车数据是：
        第1辆汽车是{地图外部：R0，排序是0，类型是3}
        第2辆汽车是{地图外部：R1，排序是0，类型是2}
        第3辆汽车是{地图外部：R1，排序是1，类型是1}
        那么，按下面步骤初始化创建汽车：
        （a）创建预制itemCarR3，父节点是UILevel/AnimNode/nodeCar/nodeR0
        （b）创建预制itemCarR2，父节点是UILevel/AnimNode/nodeCar/nodeR1
        （c）创建预制itemCarR1，父节点是UILevel/AnimNode/nodeCar/nodeR2
    第1关的汽车数据是：
        第1辆汽车是{地图外部：U0，排序是0，类型是3}
        第2辆汽车是{地图外部：U1，排序是0，类型是2}
        第3辆汽车是{地图外部：U2，排序是0，类型是1}
    第2关的汽车数据是：
        第1辆汽车是{地图外部：U0，排序是0，类型是3}
        第2辆汽车是{地图外部：U1，排序是0，类型是2}
        第3辆汽车是{地图外部：U1，排序是1，类型是1}
        第4辆汽车是{地图外部：R0，排序是0，类型是2}
        第5辆汽车是{地图外部：R0，排序是1，类型是1}
        第6辆汽车是{地图外部：R1，排序是0，类型是3}
        第7辆汽车是{地图外部：R2，排序是0，类型是3}
    第3关的汽车数据是：
        第1辆汽车是{地图外部：U1，排序是0，类型是3}
        第2辆汽车是{地图外部：U2，排序是0，类型是3}
        第3辆汽车是{地图外部：U2，排序是1，类型是3}
        第4辆汽车是{地图外部：U3，排序是0，类型是3}
        第5辆汽车是{地图外部：L0，排序是0，类型是2}
        第6辆汽车是{地图外部：L4，排序是0，类型是2}
        第7辆汽车是{地图外部：R0，排序是0，类型是2}
        第8辆汽车是{地图外部：R4，排序是0，类型是2}
    第4关的汽车数据是：
        第1辆汽车是{地图外部：U0，排序是0，类型是3}
        第2辆汽车是{地图外部：U4，排序是0，类型是3}
        第3辆汽车是{地图外部：L3，排序是0，类型是1}
        第4辆汽车是{地图外部：L3，排序是1，类型是1}
        第5辆汽车是{地图外部：R4，排序是0，类型是2}
        第6辆汽车是{地图外部：R4，排序是1，类型是1}
    第5关的汽车数据是：
        第1辆汽车是{地图外部：U0，排序是0，类型是3}
        第2辆汽车是{地图外部：L1，排序是0，类型是3}
        第3辆汽车是{地图外部：L3，排序是0，类型是3}
        第4辆汽车是{地图外部：L4，排序是0，类型是3}
        第5辆汽车是{地图外部：R2，排序是0，类型是3}
        第6辆汽车是{地图外部：R5，排序是0，类型是3}
（9）点击汽车时，，打印父节点，汽车预制名称，汽车世界坐标。并且，隐藏汽车active = false。
    另外，以UILevel/AnimNode/nodePark为父节点，用汽车世界坐标+(0,600)的世界坐标创建新的汽车预制。
（10）点击汽车时，
        （10.1）如果是Ux的汽车，即地图下方的汽车，遍历检查Map[x][MapH-1]到Map[x][0]：
                找出最后一个是零的i，遍历过程同时统计Map[x][i]是零的总数量。
        （10.2）如果零的总数量<汽车长度，那么停车失败。
        （10.3）如果零的总数量≥汽车长度，那么停车成功：
            （a）成功停车计数+1。Map[x][i]~Map[x][i+汽车长度–1]都从0变为1。
            （b）隐藏被点击的汽车active = false。
            （c）以UILevel/AnimNode/nodePark为父节点，用被点击的汽车世界坐标+(0,100*i)的世界坐标创建新的汽车预制。
            （d）检查是否已停满所有汽车
（11）新的关卡，要删除掉UILevel/AnimNode/nodePark里边所有子节点
（12）让ai解耦合
（13）创建汽车时，汽车的坐标需要根据汽车类型type和排序sort适配：
    （13.1）同样在Ux的汽车，第1辆type=2汽车是(0,0),第2辆type=3汽车是第1辆汽车坐标-(0,100*第1辆type),第3辆type=1汽车是第2辆汽车坐标-(0,100*第2辆type)。
    （13.2）同样在Lx的汽车，第1辆type=2汽车是(0,0),第2辆type=3汽车是第1辆汽车坐标+(100*第1辆type,0),第3辆type=1汽车是第2辆汽车坐标+(100*第2辆type,0)。
    （13.3）同样在Rx的汽车，第1辆type=2汽车是(0,0),第2辆type=3汽车是第1辆汽车坐标-(100*第1辆type,0),第3辆type=1汽车是第2辆汽车坐标-(100*第2辆type,0)。
（14）创建完汽车后，要根据需停好的汽车存若干份地图外的停车信息数据。
    （14.1）Ux的汽车，根据Ux里所有汽车的sort和type，存一份数据：地图外的停车信息，记作OutMapUx[Ux的汽车占用空间]。
        比如，Ux的汽车：
            第1辆汽车是{地图外部：U0，排序是0，类型是3},
            第2辆汽车是{地图外部：U1，排序是0，类型是2}，
            第3辆汽车是{地图外部：U1，排序是1，类型是1}，
        那么，OutMapU1只有1辆长度3的车，OutMapU1[3] = {1,1,1}，
            OutMapU2有1辆长度2和1辆长度1的车，OutMapU2[3] = {1,1,1}，
    （14.2）Lx的汽车，根据Lx里所有汽车的sort和type，存一份数据：地图外的停车信息，记作OutMapLx[Lx的汽车占用空间]。
        比如，Lx的汽车：
            第1辆汽车是{地图外部：L3，排序是0，类型是1},
            第2辆汽车是{地图外部：L3，排序是1，类型是1},
        那么，OutMapL3有1辆长度1和1辆长度1的车，OutMapL3[2] = {1,1}，
    （14.3）Rx的汽车，根据Rx里所有汽车的sort和type，存一份数据：地图外的停车信息，记作OutMapRx[Rx的汽车占用空间]。
        比如，Rx的汽车：
            第1辆汽车是{地图外部：R2，排序是0，类型是3},
            第2辆汽车是{地图外部：R5，排序是0，类型是3},
        那么，OutMapR2只有1辆长度3的车，OutMapR2[3] = {1,1,1}，
            OutMapR5只有1辆长度3的车，OutMapR5[3] = {1,1,1}。
    （14.4）OutMapUx,OutMapLx,OutMapRx需要整整一关游戏过程，都可以快速获取它的值
（15）创建完汽车后，要结合Map[][]和OutMapUx[]、OutMapLx[]、OutMapRx[]为每一辆汽车存停在哪里的信息数据，而且也是需要整整一关游戏过程，都可以快速获取它的值。
    第1辆汽车是{地图外部：U0，排序是0，类型是3}，
    第2辆汽车是{地图外部：U1，排序是0，类型是2}，
    第3辆汽车是{地图外部：U1，排序是1，类型是1}，
    第4辆汽车是{地图外部：R0，排序是0，类型是2}，
    第5辆汽车是{地图外部：R0，排序是1，类型是1}，
    第6辆汽车是{地图外部：R1，排序是0，类型是3}，
    第7辆汽车是{地图外部：R2，排序是0，类型是3}，
    第8辆汽车是{地图外部：L1，排序是0，类型是3}
    那么，Car1停在OutMapU0[]的0,1,2，记作Car1Stop[3]={0+mapH,1+mapH,2+mapH}，
        Car2停在OutMapU1[]的0,1，记作Car2Stop[2]={0+mapH,1+mapH}，
        Car3停在OutMapU1[]的2，记作Car3Stop[1]={2+mapH}，
        Car4停在OutMapR0[]的0,1，记作Car4Stop[2]={0-mapW,1-mapW}，
        Car5停在OutMapR0[]的2，记作Car5Stop[1]={2-mapW}，
        Car6停在OutMapR1[]的0,1,2，记作Car6Stop[3]={0-mapW,1-mapW,2-mapW}，
        Car7停在OutMapR2[]的0,1,2，记作Car7Stop[3]={0-mapW,1-mapW,2-mapW}，
        Car8停在OutMapL1[]的0,1,2，记作Car8Stop[3]={0+mapW,1+mapW,2+mapW}，

（15）修改汽车点击事件，点击汽车时：打印信息，汽车的父节点、type、sort、世界坐标、map。其它的代码都删掉。
（16）删除这个未使用的函数以精简代码：createNewCarAtPosition
（17）


地图说明：
（1）是二维数组Map[i][j]，MapW和MapH分别是i和j的上限。
（2）如果Map[i][j]为-1，表示有永久阻挡。
第1关地图：
MapW=5,MapH=6,Map[][]={
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0}。
第2关地图：
MapW=5,MapH=6,Map[][]={
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,-1,-1,-1}。
第3关地图：
MapW=5,MapH=6,Map[][]={
    0,0,0,0,0,
    -1,0,0,0,-1,
    -1,0,0,0,-1,
    -1,0,0,0,-1,
    0,0,0,0,0,
    -1,0,0,0,-1}。
第4关地图：
MapW=5,MapH=6,Map[][]={
    0,0,0,0,0,
    -1,0,0,0,-1,
    0,0,0,0,0,
    0,-1,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0}。
第5关地图：
MapW=5,MapH=6,Map[][]={
    -1,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,0,
    0,0,0,0,-1}。
